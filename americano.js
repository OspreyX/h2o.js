// Generated by CoffeeScript 1.9.1
(function() {
  var ArrayExpression, ArrayPattern, ArrowExpression, AssignmentExpression, Ast, Asts, BinaryExpression, BlockStatement, BreakStatement, Call, CallExpression, CatchClause, ComprehensionBlock, ComprehensionExpression, ComprehensionIf, ConditionalExpression, ContinueStatement, DebuggerStatement, Declaration, DoWhileStatement, EmptyStatement, Expression, ExpressionStatement, ForInStatement, ForOfStatement, ForStatement, Func, Funcs, Function, FunctionDeclaration, FunctionExpression, GeneratorExpression, GraphExpression, GraphIndexExpression, Identifier, IfStatement, LabeledStatement, LetExpression, LetStatement, Literal, LogicalExpression, MemberExpression, NewExpression, Node, ObjectExpression, ObjectPattern, Pattern, Program, Property, ReturnStatement, SExpr, SequenceExpression, Statement, SwitchCase, SwitchStatement, ThisExpression, ThrowStatement, TryStatement, UnaryExpression, UpdateExpression, VariableDeclaration, VariableDeclarator, WhileStatement, WithStatement, YieldExpression, _, dump, esprima, map, parse, walk,
    slice = [].slice;

  _ = require('lodash');

  esprima = require('esprima');

  dump = function(a) {
    return console.log(JSON.stringify(a, null, 2));
  };

  Node = 'Node';

  Program = 'Program';

  Function = 'Function';

  Statement = 'Statement';

  EmptyStatement = 'EmptyStatement';

  BlockStatement = 'BlockStatement';

  ExpressionStatement = 'ExpressionStatement';

  IfStatement = 'IfStatement';

  LabeledStatement = 'LabeledStatement';

  BreakStatement = 'BreakStatement';

  ContinueStatement = 'ContinueStatement';

  WithStatement = 'WithStatement';

  SwitchStatement = 'SwitchStatement';

  ReturnStatement = 'ReturnStatement';

  ThrowStatement = 'ThrowStatement';

  TryStatement = 'TryStatement';

  WhileStatement = 'WhileStatement';

  DoWhileStatement = 'DoWhileStatement';

  ForStatement = 'ForStatement';

  ForInStatement = 'ForInStatement';

  ForOfStatement = 'ForOfStatement';

  LetStatement = 'LetStatement';

  DebuggerStatement = 'DebuggerStatement';

  Declaration = 'Declaration';

  FunctionDeclaration = 'FunctionDeclaration';

  VariableDeclaration = 'VariableDeclaration';

  VariableDeclarator = 'VariableDeclarator';

  Expression = 'Expression';

  ThisExpression = 'ThisExpression';

  ArrayExpression = 'ArrayExpression';

  ObjectExpression = 'ObjectExpression';

  Property = 'Property';

  FunctionExpression = 'FunctionExpression';

  ArrowExpression = 'ArrowExpression';

  SequenceExpression = 'SequenceExpression';

  UnaryExpression = 'UnaryExpression';

  BinaryExpression = 'BinaryExpression';

  AssignmentExpression = 'AssignmentExpression';

  UpdateExpression = 'UpdateExpression';

  LogicalExpression = 'LogicalExpression';

  ConditionalExpression = 'ConditionalExpression';

  NewExpression = 'NewExpression';

  CallExpression = 'CallExpression';

  MemberExpression = 'MemberExpression';

  YieldExpression = 'YieldExpression';

  ComprehensionExpression = 'ComprehensionExpression';

  GeneratorExpression = 'GeneratorExpression';

  GraphExpression = 'GraphExpression';

  GraphIndexExpression = 'GraphIndexExpression';

  LetExpression = 'LetExpression';

  Pattern = 'Pattern';

  ObjectPattern = 'ObjectPattern';

  ArrayPattern = 'ArrayPattern';

  SwitchCase = 'SwitchCase';

  CatchClause = 'CatchClause';

  ComprehensionBlock = 'ComprehensionBlock';

  ComprehensionIf = 'ComprehensionIf';

  Identifier = 'Identifier';

  Literal = 'Literal';

  Funcs = {
    toDate: 'as.Date',
    toString: 'as.character',
    toNumber: 'as.numeric',
    random: 'h2o.runif'
  };

  Asts = {
    BinaryExpression: function(operator, left, right) {
      return {
        operator: operator,
        left: left,
        right: right
      };
    },
    Literal: function(value, raw) {
      return {
        value: value,
        raw: raw
      };
    },
    CallExpression: function(name, args) {
      return {
        callee: {
          type: Identifier,
          name: name
        },
        "arguments": args
      };
    }
  };

  Ast = _.mapValues(Asts, function(build, type) {
    return function() {
      var args, ast;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      ast = build.apply(null, args);
      ast.type = type;
      return ast;
    };
  });

  Call = function(name) {
    return function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return Ast.CallExpression(name, args);
    };
  };

  Func = _.mapValues(Funcs, function(remoteName, localName) {
    return Call(localName);
  });

  SExpr = function(context) {
    var Nodes, sexpr, sexprs;
    Nodes = {
      Node: null,
      Program: null,
      Function: null,
      Statement: null,
      EmptyStatement: null,
      BlockStatement: null,
      IfStatement: null,
      LabeledStatement: null,
      BreakStatement: null,
      ContinueStatement: null,
      WithStatement: null,
      SwitchStatement: null,
      ReturnStatement: null,
      ThrowStatement: null,
      TryStatement: null,
      WhileStatement: null,
      DoWhileStatement: null,
      ForStatement: null,
      ForInStatement: null,
      ForOfStatement: null,
      LetStatement: null,
      DebuggerStatement: null,
      Declaration: null,
      FunctionDeclaration: null,
      VariableDeclaration: null,
      VariableDeclarator: null,
      Expression: null,
      ThisExpression: null,
      ArrayExpression: null,
      ObjectExpression: null,
      Property: null,
      FunctionExpression: null,
      ArrowExpression: null,
      ExpressionStatement: null,
      SequenceExpression: null,
      UnaryExpression: function(node) {
        var argument, operator, prefix;
        operator = node.operator, argument = node.argument, prefix = node.prefix;
        if (prefix) {
          switch (operator) {
            case '!':
              return "(not " + (sexpr(argument)) + ")";
            case '+':
              return sexpr(Func.toNumber(argument));
            case '-':
              if (argument.type === Literal && _.isNumber(argument.value)) {
                return sexpr(Ast.Literal(-1, '-1'));
              } else {
                return sexpr(Ast.BinaryExpression('*', argument, Ast.Literal(-1, '-1')));
              }
              break;
            default:
              throw new Error("Unsupported " + node.type + " prefix operator [" + operator + "]");
          }
        } else {
          throw new Error("Unsupported " + node.type + " postfix operator [" + operator + "]");
        }
      },
      BinaryExpression: function(node) {
        var left, op, operator, right;
        operator = node.operator, left = node.left, right = node.right;
        op = (function() {
          switch (operator) {
            case '==':
            case '===':
              return 'n';
            case '!=':
            case '!==':
              return 'N';
            case '<':
              return 'l';
            case '<=':
              return 'L';
            case '>':
              return 'g';
            case '>=':
              return 'G';
            case '+':
            case '-':
            case '*':
            case '/':
              return operator;
            case '%':
              return 'mod';
            default:
              throw new Error("Unsupported " + node.type + " operator [" + operator + "]");
          }
        })();
        return "(" + op + " " + (sexpr(left)) + " " + (sexpr(right)) + ")";
      },
      AssignmentExpression: null,
      UpdateExpression: null,
      LogicalExpression: function(node) {
        var left, op, operator, right;
        operator = node.operator, left = node.left, right = node.right;
        op = (function() {
          switch (operator) {
            case '||':
              return '|';
            case '&&':
              return '&';
            default:
              throw new Error("Unsupported " + node.type + " operator [" + operator + "]");
          }
        })();
        return "(" + op + " " + (sexpr(left)) + " " + (sexpr(right)) + ")";
      },
      ConditionalExpression: null,
      NewExpression: null,
      CallExpression: function(node) {
        var arg;
        return "(" + (sexpr(node.callee)) + " " + (sexprs((function() {
          var i, len, ref, results;
          ref = node["arguments"];
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            arg = ref[i];
            results.push(sexpr(arg));
          }
          return results;
        })())) + ")";
      },
      MemberExpression: null,
      YieldExpression: null,
      ComprehensionExpression: null,
      GeneratorExpression: null,
      GraphExpression: null,
      GraphIndexExpression: null,
      LetExpression: null,
      Pattern: null,
      ObjectPattern: null,
      ArrayPattern: null,
      SwitchCase: null,
      CatchClause: null,
      ComprehensionBlock: null,
      ComprehensionIf: null,
      Identifier: function(node) {
        var callable, symbol;
        if (node.name === 'NaN') {
          return sexpr(null);
        } else if (symbol = context.globalSymbols[node.name]) {
          return "%" + symbol;
        } else if (callable = context.globalFuncs[node.name]) {
          return callable;
        } else {
          throw new Error("Unknown " + node.type + ": [" + node.name + "]");
        }
      },
      Literal: function(node) {
        var raw, value;
        value = node.value, raw = node.raw;
        if (value === null) {
          return sexpr(value);
        } else if (_.isNumber(value)) {
          return "#" + raw;
        } else if (_.isString(value)) {
          return '"' + value + '"';
        } else if (_.isBoolean(value)) {
          if (value) {
            return "%TRUE";
          } else {
            return "%FALSE";
          }
        } else {
          throw new Error("Unsupported literal [" + raw + "]");
        }
      },
      Null: function(node) {
        return '#NaN';
      }
    };
    sexprs = function(sexprs) {
      return sexprs.join(' ');
    };
    return sexpr = function(node) {
      var handler;
      if (handler = (node ? Nodes[node.type] : Nodes.Null)) {
        return handler(node);
      } else {
        throw new Error("Unsupported operation: [" + node.type + "]");
      }
    };
  };

  walk = function(ast, f) {
    var child, i, key, len, node;
    f(ast);
    for (key in ast) {
      node = ast[key];
      if (node !== void 0 && node !== null) {
        if (node instanceof Array) {
          for (i = 0, len = node.length; i < len; i++) {
            child = node[i];
            walk(child, f);
          }
        } else if ('string' === typeof node.type) {
          walk(node, f);
        }
      }
    }
  };

  parse = function(f, expectedArity) {
    var block, func, params, program, source, statement;
    if (!_.isFunction(f)) {
      throw new Error("Not a function: [" + f + "]");
    }
    source = f.toString();
    program = esprima.parse("var _O_o_ = " + source);
    func = program.body[0].declarations[0].init;
    params = func.params;
    if (params.length !== expectedArity) {
      throw new Error("Invalid function arity: expected [" + expectedArity + "], found [" + params.length + "] at " + source);
    }
    block = func.body;
    if (block.body.length > 1) {
      throw new Error('Multiple statements are not supported in function bodies');
    }
    statement = block.body[0];
    if (statement.type !== ReturnStatement) {
      throw new Error("No " + ReturnStatement + " found in function body");
    }
    return [
      params.map(function(param) {
        return param.name;
      }), statement.argument
    ];
  };

  map = function(symbols, func) {
    var ast, error, globalSymbols, i, len, param, paramIndex, params, ref, sexpr;
    ref = parse(func, symbols.length), params = ref[0], ast = ref[1];
    globalSymbols = {};
    for (paramIndex = i = 0, len = params.length; i < len; paramIndex = ++i) {
      param = params[paramIndex];
      globalSymbols[param] = symbols[paramIndex];
    }
    sexpr = SExpr({
      globalSymbols: globalSymbols,
      globalFuncs: Funcs
    });
    try {
      return sexpr(ast);
    } catch (_error) {
      error = _error;
      console.log(dump(ast));
      throw error;
    }
  };

  module.exports = {
    map: map
  };

}).call(this);
