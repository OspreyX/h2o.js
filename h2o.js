// Generated by CoffeeScript 1.9.1
(function() {
  var H2OError, META, _, _request, _uuid, connect, deepClone, dump, enc, encodeArray, encodeObject, extend, extendFrame, extendFrames, extendModel, extendModels, extractFrameKey, extractModelKey, fj, fs, lib, method, parameterize, reflect, resolve, transpiler, typeOf, unwrap, uuid,
    slice = [].slice,
    extend1 = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  fs = require('fs');

  fj = require('forkjoin');

  _ = require('lodash');

  _request = require('request');

  _uuid = require('node-uuid');

  transpiler = require('./americano.js');

  lib = {};

  dump = function(a) {
    return console.log(JSON.stringify(a, null, 2));
  };

  deepClone = function(a) {
    return JSON.parse(JSON.stringify(a));
  };

  enc = encodeURIComponent;

  uuid = function() {
    return _uuid.v4().replace(/\-/g, '');
  };

  resolve = fj.resolve;

  method = function(f) {
    return function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (args.length === f.length) {
        return f.apply(null, args);
      } else {
        return fj.fork.apply(null, [f].concat(args));
      }
    };
  };

  parameterize = function(route, form) {
    var key, pairs, value;
    if (form) {
      pairs = (function() {
        var results;
        results = [];
        for (key in form) {
          value = form[key];
          results.push(key + "=" + value);
        }
        return results;
      })();
      return route + '?' + pairs.join('&');
    } else {
      return route;
    }
  };

  encodeArray = function(array) {
    if (array) {
      if (array.length === 0) {
        return null;
      } else {
        return "[" + (array.map(function(element) {
          if (_.isNumber(element)) {
            return element;
          } else {
            return "\"" + element + "\"";
          }
        }).join(',')) + "]";
      }
    } else {
      return null;
    }
  };

  encodeObject = function(source) {
    var key, target, value;
    target = {};
    for (key in source) {
      value = source[key];
      target[key] = _.isArray(value) ? encodeArray(value) : value;
    }
    return target;
  };

  unwrap = function(go, transform) {
    return function(error, result) {
      if (error) {
        return go(error);
      } else {
        return go(null, transform(result));
      }
    };
  };

  META = '__h2o_js__';

  extend = function(obj, attributes) {
    var attribute, meta, value;
    meta = obj[META] != null ? obj[META] : obj[META] = {};
    for (attribute in attributes) {
      value = attributes[attribute];
      meta[attribute] = value;
    }
    return obj;
  };

  reflect = function(obj, attribute) {
    var meta;
    if (meta = obj != null ? obj[META] : void 0) {
      return meta[attribute];
    } else {
      return meta;
    }
  };

  typeOf = function(obj) {
    return reflect(obj, 'type');
  };

  extendFrame = function(frame) {
    return extend(frame, {
      type: 'Frame',
      key: frame.key.name
    });
  };

  extractFrameKey = function(a) {
    if (_.isString(a)) {
      return a;
    } else if ('Frame' === typeOf(a)) {
      return a.key.name;
    } else {
      return void 0;
    }
  };

  extendModel = function(model) {
    return extend(model, {
      type: 'Model'
    });
  };

  extractModelKey = function(a) {
    if (_.isString(a)) {
      return a;
    } else if ('Model' === typeOf(a)) {
      return a.key.name;
    } else {
      return void 0;
    }
  };

  extendFrames = function(frames) {
    var frame, j, len, results;
    results = [];
    for (j = 0, len = frames.length; j < len; j++) {
      frame = frames[j];
      results.push(extendFrame(frame));
    }
    return results;
  };

  extendModels = function(models) {
    var j, len, model, results;
    results = [];
    for (j = 0, len = models.length; j < len; j++) {
      model = models[j];
      results.push(extendModel(model));
    }
    return results;
  };

  H2OError = (function(superClass) {
    extend1(H2OError, superClass);

    function H2OError(message, cause) {
      this.message = message;
      if (cause) {
        this.cause = cause;
      }
    }

    H2OError.prototype.remoteMessage = null;

    H2OError.prototype.remoteType = null;

    H2OError.prototype.remoteStack = null;

    H2OError.prototype.cause = null;

    return H2OError;

  })(Error);

  connect = function(host) {
    return function(method, route, formAttribute, formData, go) {
      var opts;
      opts = {
        method: method,
        url: "" + host + route,
        json: true
      };
      if (formAttribute) {
        opts[formAttribute] = formData;
      }
      console.log(opts.method + " " + opts.url);
      return _request(opts, function(error, response, body) {
        var cause, form, h2oError, parameters, ref;
        if (!error && response.statusCode === 200) {
          return go(error, body);
        } else {
          cause = (body != null ? (ref = body.__meta) != null ? ref.schema_type : void 0 : void 0) === 'H2OError' ? (h2oError = new H2OError(body.exception_msg), h2oError.remoteMessage = body.dev_msg, h2oError.remoteType = body.exception_type, h2oError.remoteStack = body.stacktrace.join('\n'), h2oError) : (error != null ? error.message : void 0) ? new H2OError(error.message) : _.isString(error) ? new H2OError(error) : new H2OError("Unknown error: " + (JSON.stringify(error)));
          parameters = (form = opts.form) ? " with form " + (JSON.stringify(form)) : (formData = opts.formData) ? " with form data" : '';
          return go(new H2OError("Error calling " + opts.method + " " + opts.url + parameters + ".", cause));
        }
      });
    };
  };

  lib.connect = function(host) {
    var _astStatement, _bindVectors, about, astBind, astBlock, astColNames, astConcat, astFilter, astList, astNull, astNumber, astNumbers, astPut, astRange, astRead, astSlice, astStatement, astString, astStrings, astWrite, bindVectors, buildModel, cancelJob, concatFrames, createFrame, createModel, createPrediction, del, evaluate, filterFrame, get, getClusterStatus, getColumnSummary, getEndpoint, getEndpoints, getFrame, getFrames, getJob, getJobs, getLogFile, getModel, getModelBuilder, getModelBuilders, getModels, getPrediction, getPredictions, getRDDs, getSchema, getSchemas, getStackTrace, getTimeline, importFile, importFiles, importFrame, mapVectors, parseFiles, patchUpModels, post, remove, removeAll, removeFrame, removeModel, request, requestModelInputValidation, resolveParameters, runNetworkTest, runProfiler, selectVector, setupParse, shutdown, sliceFrame, splitFrame, upload, uploadFile, waitForJob, whitespace;
    if (host == null) {
      host = 'http://localhost:54321';
    }
    request = connect(host);
    get = function() {
      var args, form, go, j, route;
      args = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), go = arguments[j++];
      route = args[0], form = args[1];
      return request('GET', parameterize(route, form), void 0, void 0, go);
    };
    post = function(route, form, go) {
      return request('POST', route, 'form', form, go);
    };
    upload = function(route, formData, go) {
      return request('POST', route, 'formData', formData, go);
    };
    del = function(route, go) {
      return request('DELETE', route, void 0, void 0, go);
    };
    splitFrame = method(function(parameters, go) {
      return post('/2/SplitFrame.json', encodeObject(parameters), go);
    });
    getFrames = method(function(go) {
      return get('/3/Frames.json', unwrap(go, function(result) {
        return extendFrames(result.frames);
      }));
    });
    getFrame = method(function(key, go) {
      if (!_.isString(key)) {
        return go(new Error('Parameter [key]: expected string'));
      }
      if (key === '') {
        return go(new Error('Parameter [key]: expected non-empty string'));
      }
      return get("/3/Frames.json/" + (enc(key)), unwrap(go, function(result) {
        return _.head(extendFrames(result.frames));
      }));
    });
    removeFrame = method(function(key, go) {
      return del("/3/Frames.json/" + (enc(key)), go);
    });
    getRDDs = method(function(go) {
      return get('/3/RDDs.json', unwrap(go, function(result) {
        return result.rdds;
      }));
    });
    getColumnSummary = method(function(key, column, go) {
      return get("/3/Frames.json/" + (enc(key)) + "/columns/" + (enc(column)) + "/summary", unwrap(go, function(result) {
        return _.head(result.frames);
      }));
    });
    getJobs = method(function(go) {
      return get('/2/Jobs.json', unwrap(go, function(result) {
        return result.jobs;
      }));
    });
    getJob = method(function(key, go) {
      return get("/2/Jobs.json/" + (enc(key)), unwrap(go, function(result) {
        return _.head(result.jobs);
      }));
    });
    waitForJob = method(function(key, go) {
      var poll;
      poll = function() {
        return getJob(key, function(error, job) {
          if (error) {
            return go(error);
          } else {
            switch (job.status) {
              case 'DONE':
                return go(null, job);
              case 'CREATED':
              case 'RUNNING':
                return setTimeout(poll, 1000);
              default:
                return go(new H2OError("Job " + key + " failed: " + job.exception), job);
            }
          }
        });
      };
      return poll();
    });
    cancelJob = method(function(key, go) {
      return post("/2/Jobs.json/" + (enc(key)) + "/cancel", {}, go);
    });
    importFile = method(function(parameters, go) {
      var form;
      form = {
        path: enc(parameters.path)
      };
      return get('/2/ImportFiles.json', form, go);
    });
    importFiles = method(function(parameters, go) {
      return (fj.seq(parameters.map(function(parameters) {
        return fj.fork(importFile, parameters);
      })))(go);
    });
    setupParse = method(function(parameters, go) {
      var form;
      form = {
        source_keys: encodeArray(parameters.source_keys)
      };
      return post('/2/ParseSetup.json', form, go);
    });
    parseFiles = method(function(parameters, go) {
      return post('/2/Parse.json', encodeObject(parameters), go);
    });
    importFrame = method(function(parameters, go) {
      var frame, importResult, job, parseResult, setupResult;
      importResult = importFile({
        path: parameters.path
      });
      setupResult = fj.lift(importResult, function(result) {
        return setupParse({
          source_keys: result.keys
        });
      });
      parseResult = fj.lift(setupResult, function(result) {
        dump(result);
        return parseFiles({
          destination_key: result.destination_key,
          source_keys: result.source_keys.map(function(key) {
            return key.name;
          }),
          parse_type: result.parse_type,
          separator: result.separator,
          number_columns: result.number_columns,
          single_quotes: result.single_quotes,
          column_names: result.column_names,
          column_types: result.column_types,
          check_header: result.check_header,
          chunk_size: result.chunk_size,
          delete_on_done: true
        });
      });
      job = fj.lift(parseResult, function(result) {
        return waitForJob(result.job.key.name);
      });
      frame = fj.lift(job, function(job) {
        return getFrame(job.dest.name);
      });
      return frame(go);
    });
    patchUpModels = method(function(models) {
      var j, k, len, len1, model, parameter, parseError, ref;
      for (j = 0, len = models.length; j < len; j++) {
        model = models[j];
        ref = model.parameters;
        for (k = 0, len1 = ref.length; k < len1; k++) {
          parameter = ref[k];
          switch (parameter.type) {
            case 'Key<Frame>':
            case 'Key<Model>':
            case 'VecSpecifier':
              if (_.isString(parameter.actual_value)) {
                try {
                  parameter.actual_value = JSON.parse(parameter.actual_value);
                } catch (_error) {
                  parseError = _error;
                }
              }
          }
        }
      }
      return models;
    });
    getModels = method(function(go) {
      return get('/3/Models.json', unwrap(go, function(result) {
        return patchUpModels(extendModels(result.models));
      }));
    });
    getModel = method(function(key, go) {
      return get("/3/Models.json/" + (enc(key)), unwrap(go, function(result) {
        return _.head(patchUpModels(extendModels(result.models)));
      }));
    });
    removeModel = method(function(key, go) {
      return del("/3/Models.json/" + (enc(key)), go);
    });
    getModelBuilders = method(function(go) {
      return get("/3/ModelBuilders.json", go);
    });
    getModelBuilder = method(function(algo, go) {
      return get("/3/ModelBuilders.json/" + algo, go);
    });
    requestModelInputValidation = method(function(algo, parameters, go) {
      return post("/3/ModelBuilders.json/" + algo + "/parameters", encodeObject(parameters), go);
    });
    resolveParameters = method(function(parameters, go) {
      var key, obj, resolved, unresolveds;
      unresolveds = [];
      resolved = {};
      for (key in parameters) {
        obj = parameters[key];
        if (fj.isFuture(obj)) {
          unresolveds.push({
            key: key,
            future: obj
          });
        } else {
          resolved[key] = obj;
        }
      }
      if (unresolveds.length) {
        return (fj.map(unresolveds, (function(a) {
          return a.future;
        })))(function(error, values) {
          var i, j, len, value;
          if (error) {
            return go(error);
          } else {
            for (i = j = 0, len = values.length; j < len; i = ++j) {
              value = values[i];
              resolved[unresolveds[i].key] = value;
            }
            return go(null, resolved);
          }
        });
      } else {
        return go(null, resolved);
      }
    });
    buildModel = method(function(algo, parameters, go) {
      return post("/3/ModelBuilders.json/" + algo, encodeObject(parameters), go);
    });
    createModel = method(function(algo, parameters, go) {
      var build, job, model, resolvedParameters;
      resolvedParameters = resolveParameters(parameters);
      build = fj.lift(resolvedParameters, function(parameters) {
        var trainingFrameKey, validationFrameKey;
        trainingFrameKey = extractFrameKey(parameters.training_frame);
        validationFrameKey = extractFrameKey(parameters.validation_frame);
        delete parameters.training_frame;
        delete parameters.validation_frame;
        if (trainingFrameKey) {
          parameters.training_frame = trainingFrameKey;
        }
        if (validationFrameKey) {
          parameters.validation_frame = validationFrameKey;
        }
        return buildModel(algo, parameters);
      });
      job = fj.lift(build, function(build) {
        return waitForJob(build.job.key.name);
      });
      model = fj.lift(job, function(job) {
        return getModel(job.dest.name);
      });
      return model(go);
    });
    createPrediction = method(function(parameters, go) {
      return resolveParameters(parameters, function(error, parameters) {
        var frameKey, modelKey;
        if (error) {
          return go(error);
        } else {
          modelKey = extractModelKey(parameters.model);
          frameKey = extractFrameKey(parameters.frame);
          delete parameters.model;
          delete parameters.frame;
          return post("/3/Predictions.json/models/" + (enc(modelKey)) + "/frames/" + (enc(frameKey)), parameters, unwrap(go, function(result) {
            return _.head(result.model_metrics);
          }));
        }
      });
    });
    getPrediction = method(function(modelKey, frameKey, go) {
      return get("/3/ModelMetrics.json/models/" + (enc(modelKey)) + "/frames/" + (enc(frameKey)), unwrap(go, function(result) {
        return _.head(result.model_metrics);
      }));
    });
    getPredictions = method(function(modelKey, frameKey, _go) {
      var go;
      go = function(error, result) {
        var prediction, predictions;
        if (error) {
          return _go(error);
        } else {
          predictions = (function() {
            var j, len, ref, results;
            ref = result.model_metrics;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              prediction = ref[j];
              if (modelKey && prediction.model.name !== modelKey) {
                results.push(null);
              } else if (frameKey && prediction.frame.name !== frameKey) {
                results.push(null);
              } else {
                results.push(prediction);
              }
            }
            return results;
          })();
          return _go(null, (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = predictions.length; j < len; j++) {
              prediction = predictions[j];
              if (prediction) {
                results.push(prediction);
              }
            }
            return results;
          })());
        }
      };
      if (modelKey && frameKey) {
        return get("/3/ModelMetrics.json/models/" + (enc(modelKey)) + "/frames/" + (enc(frameKey)), go);
      } else if (modelKey) {
        return get("/3/ModelMetrics.json/models/" + (enc(modelKey)), go);
      } else if (frameKey) {
        return get("/3/ModelMetrics.json/frames/" + (enc(frameKey)), go);
      } else {
        return get("/3/ModelMetrics.json", go);
      }
    });
    uploadFile = method(function(key, path, go) {
      var formData;
      formData = {
        file: fs.createReadStream(path)
      };
      return upload("/3/PostFile.json?destination_key=" + (enc(key)), formData, go);
    });
    getClusterStatus = method(function(go) {
      return get('/1/Cloud.json', go);
    });
    getTimeline = method(function(go) {
      return get('/2/Timeline.json', go);
    });
    getStackTrace = method(function(go) {
      return get('/2/JStack.json', go);
    });
    getLogFile = method(function(nodeIndex, fileType, go) {
      return get("/3/Logs.json/nodes/" + nodeIndex + "/files/" + fileType, go);
    });
    runProfiler = method(function(depth, go) {
      return get("/2/Profiler.json?depth=" + depth, go);
    });
    runNetworkTest = method(function(go) {
      return get('/2/NetworkTest.json', go);
    });
    about = method(function(go) {
      return get('/3/About.json', go);
    });
    evaluate = method(function(ast, go) {
      console.log(ast);
      return post('/1/Rapids.json', {
        ast: ast
      }, function(error, result) {
        if (error) {
          return go(error);
        } else {
          if (result.error) {
            return go(new Error(result.error));
          } else {
            return go(null, result);
          }
        }
      });
    });
    getSchemas = method(function(go) {
      return get('/1/Metadata/schemas.json', unwrap(go, function(result) {
        return result.schemas;
      }));
    });
    getSchema = method(function(name, go) {
      return get("/1/Metadata/schemas.json/" + (enc(name)), unwrap(go, function(result) {
        return _.head(result.schemas);
      }));
    });
    getEndpoints = method(function(go) {
      return get('/1/Metadata/endpoints.json', unwrap(go, function(result) {
        return result.routes;
      }));
    });
    getEndpoint = method(function(index, go) {
      return get("/1/Metadata/endpoints.json/" + index, unwrap(go, function(result) {
        return _.head(result.routes);
      }));
    });
    remove = method(function(key, go) {
      return del('/1/Remove.json', go);
    });
    removeAll = method(function(go) {
      return del('/1/RemoveAll.json', go);
    });
    shutdown = method(function(go) {
      return post("/2/Shutdown.json", {}, go);
    });
    whitespace = /\s+/;
    _astStatement = function(op, args) {
      return "(" + ([op].concat(args).join(' ')) + ")";
    };
    astStatement = function() {
      var args, op;
      op = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return _astStatement(op, args);
    };
    astString = function(string) {
      return JSON.stringify(string);
    };
    astNumber = function(number) {
      return "#" + number;
    };
    astWrite = function(key) {
      if (whitespace.test(key)) {
        return astString(key);
      } else {
        return "!" + key;
      }
    };
    astRead = function(key) {
      if (whitespace.test(key)) {
        return astString(key);
      } else {
        return "%" + key;
      }
    };
    astList = function(list) {
      return "{" + (list.join(';')) + "}";
    };
    astRange = function(begin, end) {
      return astList([astStatement(':', astNumber(begin), astNumber(end))]);
    };
    astStrings = function(strings) {
      var string;
      return astList((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = strings.length; j < len; j++) {
          string = strings[j];
          results.push(astString(string));
        }
        return results;
      })());
    };
    astNumbers = function(numbers) {
      var number;
      return astList((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = numbers.length; j < len; j++) {
          number = numbers[j];
          results.push(astNumber(number));
        }
        return results;
      })());
    };
    astPut = function(key, op) {
      return astStatement('=', astWrite(key), op);
    };
    astBind = function(keys) {
      return _astStatement('cbind', keys.map(astRead));
    };
    astConcat = function(keys) {
      return _astStatement('rbind', keys.map(astRead));
    };
    astColNames = function(key, names) {
      return astStatement('colnames=', astRead(key), astRange(0, names.length - 1), astStrings(names));
    };
    astBlock = function() {
      var ops;
      ops = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return _astStatement(',', ops);
    };
    astNull = function() {
      return '"null"';
    };
    astFilter = function(key, op) {
      return astStatement('[', astRead(key), op, astNull());
    };
    astSlice = function(key, begin, end) {
      return astStatement('[', astRead(key), astRange(begin, end), astNull());
    };
    selectVector = method(function(frame, label, go) {
      return fj.resolve(frame, function(error, frame) {
        var j, len, ref, vector, vectorIndex, vectorKey;
        if (error) {
          return go(error);
        } else {
          if (_.isNumber(label)) {
            vector = frame.columns[label];
            if (vector) {
              vectorKey = frame.vec_keys[label].name;
              return go(null, extend(vector, {
                type: 'Vector',
                key: vectorKey
              }));
            } else {
              return go(new Error("Vector at index [" + label + "] not found in Frame [" + frame.key.name + "]"));
            }
          } else {
            ref = frame.columns;
            for (vectorIndex = j = 0, len = ref.length; j < len; vectorIndex = ++j) {
              vector = ref[vectorIndex];
              if (!(vector.label === label)) {
                continue;
              }
              vectorKey = frame.vec_keys[vectorIndex].name;
              return go(null, extend(vector, {
                type: 'Vector',
                key: vectorKey
              }));
            }
            return go(new Error("Vector [" + label + "] not found in Frame [" + frame.key.name + "]"));
          }
        }
      });
    });
    mapVectors = method(function(arg, func, go) {
      var vectors_;
      vectors_ = _.isArray(arg) ? arg : [arg];
      return fj.join(vectors_, function(error, vectors) {
        var op, targetKey, vectorKeys;
        if (error) {
          return go(error);
        } else {
          vectorKeys = vectors.map(function(vector) {
            return reflect(vector, 'key');
          });
          try {
            op = transpiler.map(vectorKeys, func);
            targetKey = uuid();
            return evaluate(astPut(targetKey, op), function(error, vector) {
              if (error) {
                return go(error);
              } else {
                return go(null, extend(vector, {
                  type: 'Vector',
                  key: targetKey
                }));
              }
            });
          } catch (_error) {
            error = _error;
            console.log(func.toString());
            return go(error);
          }
        }
      });
    });
    filterFrame = method(function(frame_, arg, func, go) {
      var deps_, vectors_;
      vectors_ = _.isArray(arg) ? arg : [arg];
      deps_ = [frame_].concat(vectors_);
      return fj.join(deps_, function(error, deps) {
        var frame, op, sourceKey, targetKey, vectorKeys, vectors;
        if (error) {
          return go(error);
        } else {
          frame = deps[0], vectors = 2 <= deps.length ? slice.call(deps, 1) : [];
          sourceKey = frame.key.name;
          vectorKeys = vectors.map(function(vector) {
            return reflect(vector, 'key');
          });
          try {
            op = transpiler.map(vectorKeys, func);
            targetKey = uuid();
            return evaluate(astPut(targetKey, astFilter(sourceKey, op)), function(error, frame) {
              if (error) {
                return go(error);
              } else {
                return go(null, extendFrame(frame));
              }
            });
          } catch (_error) {
            error = _error;
            return go(error);
          }
        }
      });
    });
    sliceFrame = method(function(frame_, begin, end, go) {
      return fj.join([frame_], function(error, result) {
        var frame, sourceKey, targetKey;
        if (error) {
          return go(error);
        } else {
          frame = result[0];
          sourceKey = frame.key.name;
          targetKey = uuid();
          return evaluate(astPut(targetKey, astSlice(sourceKey, begin, end - 1)), function(error, frame) {
            if (error) {
              return go(error);
            } else {
              return go(null, extendFrame(frame));
            }
          });
        }
      });
    });
    _bindVectors = method(function(targetKey, vectors, go) {
      return fj.join(vectors, function(error, vectors) {
        var vectorKeys;
        if (error) {
          return go(error);
        } else {
          vectorKeys = vectors.map(function(vector) {
            return reflect(vector, 'key');
          });
          return evaluate(astPut(targetKey, astBind(vectorKeys)), function(error, frame) {
            if (error) {
              return go(error);
            } else {
              return go(null, extendFrame(frame));
            }
          });
        }
      });
    });
    bindVectors = method(function(vectors, go) {
      return _bindVectors(uuid(), vectors, go);
    });
    createFrame = method(function(parameters, go) {
      var columnNames, columns, name, vectors_;
      name = parameters.name, columns = parameters.columns;
      columnNames = _.keys(columns);
      vectors_ = _.values(columns);
      return _bindVectors(name, vectors_, function(error, frame) {
        if (error) {
          return go(error);
        } else {
          return evaluate(astColNames(frame.key.name, columnNames), function(error, frame) {
            if (error) {
              return go(error);
            } else {
              return go(null, extendFrame(frame));
            }
          });
        }
      });
    });
    concatFrames = method(function(frames_, go) {
      return fj.join(frames_, function(error, frames) {
        var keys;
        if (error) {
          return go(error);
        } else {
          keys = frames.map(function(frame) {
            return frame.key.name;
          });
          return evaluate(astConcat(keys), function(error, frame) {
            if (error) {
              return go(error);
            } else {
              return go(null, extendFrame(frame));
            }
          });
        }
      });
    });
    return {
      importFile: importFile,
      importFiles: importFiles,
      uploadFile: uploadFile,
      parseFiles: parseFiles,
      createFrame: createFrame,
      importFrame: importFrame,
      splitFrame: splitFrame,
      getFrames: getFrames,
      getFrame: getFrame,
      removeFrame: removeFrame,
      getColumnSummary: getColumnSummary,
      createModel: createModel,
      getModels: getModels,
      getModel: getModel,
      removeModel: removeModel,
      createPrediction: createPrediction,
      getPredictions: getPredictions,
      getPrediction: getPrediction,
      getJobs: getJobs,
      getJob: getJob,
      cancelJob: cancelJob,
      getSchemas: getSchemas,
      getSchema: getSchema,
      getEndpoints: getEndpoints,
      getEndpoint: getEndpoint,
      remove: remove,
      removeAll: removeAll,
      shutdown: shutdown,
      getClusterStatus: getClusterStatus,
      getTimeline: getTimeline,
      getStackTrace: getStackTrace,
      getLogFile: getLogFile,
      runProfiler: runProfiler,
      runNetworkTest: runNetworkTest,
      about: about,
      bind: bindVectors,
      select: selectVector,
      map: mapVectors,
      filter: filterFrame,
      slice: sliceFrame,
      concat: concatFrames,
      resolve: resolve,
      error: H2OError,
      dump: dump
    };
  };

  module.exports = lib;

}).call(this);
