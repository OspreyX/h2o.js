// Generated by CoffeeScript 1.9.1
(function() {
  var H2OError, _, _request, _uuid, connect, deepClone, dump, enc, encodeArray, encodeObject, extendFrame, extendFrames, extendModel, extendModels, extractFrameKey, extractModelKey, fj, fs, getH2OType, lib, method, parameterize, unwrap, uuid,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  fs = require('fs');

  fj = require('forkjoin');

  _ = require('lodash');

  _request = require('request');

  _uuid = require('node-uuid');

  lib = {};

  dump = function(a) {
    return console.log(JSON.stringify(a, null, 2));
  };

  deepClone = function(a) {
    return JSON.parse(JSON.stringify(a));
  };

  enc = encodeURIComponent;

  uuid = function() {
    return _uuid.v4();
  };

  method = function(f) {
    return function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (args.length === f.length) {
        return f.apply(null, args);
      } else {
        return fj.fork.apply(null, [f].concat(args));
      }
    };
  };

  parameterize = function(route, form) {
    var key, pairs, value;
    if (form) {
      pairs = (function() {
        var results;
        results = [];
        for (key in form) {
          value = form[key];
          results.push(key + "=" + value);
        }
        return results;
      })();
      return route + '?' + pairs.join('&');
    } else {
      return route;
    }
  };

  encodeArray = function(array) {
    if (array) {
      if (array.length === 0) {
        return null;
      } else {
        return "[" + (array.map(function(element) {
          if (_.isNumber(element)) {
            return element;
          } else {
            return "\"" + element + "\"";
          }
        }).join(',')) + "]";
      }
    } else {
      return null;
    }
  };

  encodeObject = function(source) {
    var key, target, value;
    target = {};
    for (key in source) {
      value = source[key];
      target[key] = _.isArray(value) ? encodeArray(value) : value;
    }
    return target;
  };

  unwrap = function(go, transform) {
    return function(error, result) {
      if (error) {
        return go(error);
      } else {
        return go(null, transform(result));
      }
    };
  };

  getH2OType = function(obj) {
    var ref;
    return obj != null ? (ref = obj.__h2o_js__) != null ? ref.type : void 0 : void 0;
  };

  extendFrame = function(frame) {
    frame.__h2o_js__ = {
      type: 'Frame'
    };
    return frame;
  };

  extractFrameKey = function(a) {
    if (_.isString(a)) {
      return a;
    } else if ('Frame' === getH2OType(a)) {
      return a.key.name;
    } else {
      return void 0;
    }
  };

  extendModel = function(model) {
    model.__h2o_js__ = {
      type: 'Model'
    };
    return model;
  };

  extractModelKey = function(a) {
    if (_.isString(a)) {
      return a;
    } else if ('Model' === getH2OType(a)) {
      return a.key.name;
    } else {
      return void 0;
    }
  };

  extendFrames = function(frames) {
    var frame, j, len, results;
    results = [];
    for (j = 0, len = frames.length; j < len; j++) {
      frame = frames[j];
      results.push(extendFrame(frame));
    }
    return results;
  };

  extendModels = function(models) {
    var j, len, model, results;
    results = [];
    for (j = 0, len = models.length; j < len; j++) {
      model = models[j];
      results.push(extendModel(model));
    }
    return results;
  };

  H2OError = (function(superClass) {
    extend(H2OError, superClass);

    function H2OError(message, cause) {
      this.message = message;
      if (cause) {
        this.cause = cause;
      }
    }

    H2OError.prototype.remoteMessage = null;

    H2OError.prototype.remoteType = null;

    H2OError.prototype.remoteStack = null;

    H2OError.prototype.cause = null;

    return H2OError;

  })(Error);

  connect = function(host) {
    return function(method, route, formAttribute, formData, go) {
      var opts;
      opts = {
        method: method,
        url: "" + host + route,
        json: true
      };
      if (formAttribute) {
        opts[formAttribute] = formData;
      }
      console.log(opts.method + " " + opts.url);
      return _request(opts, function(error, response, body) {
        var cause, form, h2oError, parameters, ref;
        if (error) {
          cause = (body != null ? (ref = body.__meta) != null ? ref.schema_type : void 0 : void 0) === 'H2OError' ? (h2oError = new H2OError(body.exception_msg), h2oError.remoteMessage = body.dev_msg, h2oError.remoteType = body.exception_type, h2oError.remoteStack = body.stacktrace.join('\n'), h2oError) : (error != null ? error.message : void 0) ? new H2OError(error.message) : _.isString(error) ? new H2OError(error) : new H2OError("Unknown error: " + (JSON.stringify(error)));
          parameters = (form = opts.form) ? " with form " + (JSON.stringify(form)) : (formData = opts.formData) ? " with form data" : '';
          return go(new H2OError("Error calling " + opts.method + " " + opts.url + parameters + ".", cause));
        } else {
          return go(error, body);
        }
      });
    };
  };

  lib.connect = function(host) {
    var buildModel, cancelJob, createFrame, createModel, del, deleteAll, deleteFrame, deleteModel, get, getColumnSummary, getEndpoint, getEndpoints, getFrame, getFrames, getJob, getJobs, getModel, getModelBuilder, getModelBuilders, getModels, getPrediction, getPredictions, getRDDs, getSchema, getSchemas, importFile, importFiles, importFrame, parseFiles, patchUpModels, post, predict, request, requestAbout, requestCloud, requestLogFile, requestModelInputValidation, requestNetworkTest, requestParseSetupPreview, requestProfile, requestStackTrace, requestTimeline, resolveParameters, setupParse, shutdown, splitFrame, upload, uploadFile, waitForJob;
    if (host == null) {
      host = 'http://localhost:54321';
    }
    request = connect(host);
    get = function() {
      var args, form, go, j, route;
      args = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), go = arguments[j++];
      route = args[0], form = args[1];
      return request('GET', parameterize(route, form), void 0, void 0, go);
    };
    post = function(route, form, go) {
      return request('POST', route, 'form', form, go);
    };
    upload = function(route, formData, go) {
      return request('POST', route, 'formData', formData, go);
    };
    del = function(route, go) {
      return request('DELETE', route, void 0, void 0, go);
    };
    createFrame = method(function(parameters, go) {
      return post('/2/CreateFrame.json', parameters, go);
    });
    splitFrame = method(function(parameters, go) {
      return post('/2/SplitFrame.json', encodeObject(parameters), go);
    });
    getFrames = method(function(go) {
      return get('/3/Frames.json', unwrap(go, function(result) {
        return extendFrames(result.frames);
      }));
    });
    getFrame = method(function(key, go) {
      return get("/3/Frames.json/" + (enc(key)), unwrap(go, function(result) {
        return _.head(extendFrames(result.frames));
      }));
    });
    deleteFrame = method(function(key, go) {
      return del("/3/Frames.json/" + (enc(key)), go);
    });
    getRDDs = method(function(go) {
      return get('/3/RDDs.json', unwrap(go, function(result) {
        return result.rdds;
      }));
    });
    getColumnSummary = method(function(key, column, go) {
      return get("/3/Frames.json/" + (enc(key)) + "/columns/" + (enc(column)) + "/summary", unwrap(go, function(result) {
        return _.head(result.frames);
      }));
    });
    getJobs = method(function(go) {
      return get('/2/Jobs.json', unwrap(go, function(result) {
        return result.jobs;
      }));
    });
    getJob = method(function(key, go) {
      return get("/2/Jobs.json/" + (enc(key)), unwrap(go, function(result) {
        return _.head(result.jobs);
      }));
    });
    waitForJob = method(function(key, go) {
      var poll;
      poll = function() {
        return getJob(key, function(error, job) {
          if (error) {
            return go(error);
          } else {
            switch (job.status) {
              case 'DONE':
                return go(null, job);
              case 'CREATED':
              case 'RUNNING':
                return setTimeout(poll, 1000);
              default:
                return go(new H2OError("Job " + key + " failed: " + job.exception), job);
            }
          }
        });
      };
      return poll();
    });
    cancelJob = method(function(key, go) {
      return post("/2/Jobs.json/" + (enc(key)) + "/cancel", {}, go);
    });
    importFile = method(function(parameters, go) {
      var form;
      form = {
        path: enc(parameters.path)
      };
      return get('/2/ImportFiles.json', form, go);
    });
    importFiles = method(function(parameters, go) {
      return (fj.seq(parameters.map(function(parameters) {
        return fj.fork(importFile, parameters);
      })))(go);
    });
    setupParse = method(function(parameters, go) {
      var form;
      form = {
        source_keys: encodeArray(parameters.source_keys)
      };
      return post('/2/ParseSetup.json', form, go);
    });
    requestParseSetupPreview = method(function(sourceKeys, parseType, separator, useSingleQuotes, checkHeader, columnTypes, go) {
      var parameters;
      parameters = {
        source_keys: encodeArray(sourceKeys),
        parse_type: parseType,
        separator: separator,
        single_quotes: useSingleQuotes,
        check_header: checkHeader,
        column_types: encodeArray(columnTypes)
      };
      return post('/2/ParseSetup.json', parameters, go);
    });
    parseFiles = method(function(parameters, go) {
      return post('/2/Parse.json', encodeObject(parameters), go);
    });
    importFrame = method(function(parameters, go) {
      var frame, importResult, job, parseResult, setupResult;
      importResult = importFile({
        path: parameters.path
      });
      setupResult = fj.lift(importResult, function(result) {
        return setupParse({
          source_keys: result.keys
        });
      });
      parseResult = fj.lift(setupResult, function(result) {
        return parseFiles({
          destination_key: result.destination_key,
          source_keys: result.source_keys.map(function(key) {
            return key.name;
          }),
          parse_type: result.parse_type,
          separator: result.separator,
          number_columns: result.number_columns,
          single_quotes: result.single_quotes,
          column_names: result.column_names,
          column_types: result.column_types,
          check_header: result.check_header,
          chunk_size: result.chunk_size,
          delete_on_done: true
        });
      });
      job = fj.lift(parseResult, function(result) {
        return waitForJob(result.job.key.name);
      });
      frame = fj.lift(job, function(job) {
        return getFrame(job.dest.name);
      });
      return frame(go);
    });
    patchUpModels = method(function(models) {
      var j, k, len, len1, model, parameter, parseError, ref;
      for (j = 0, len = models.length; j < len; j++) {
        model = models[j];
        ref = model.parameters;
        for (k = 0, len1 = ref.length; k < len1; k++) {
          parameter = ref[k];
          switch (parameter.type) {
            case 'Key<Frame>':
            case 'Key<Model>':
            case 'VecSpecifier':
              if (_.isString(parameter.actual_value)) {
                try {
                  parameter.actual_value = JSON.parse(parameter.actual_value);
                } catch (_error) {
                  parseError = _error;
                }
              }
          }
        }
      }
      return models;
    });
    getModels = method(function(go) {
      return get('/3/Models.json', unwrap(go, function(result) {
        return patchUpModels(extendModels(result.models));
      }));
    });
    getModel = method(function(key, go) {
      return get("/3/Models.json/" + (enc(key)), unwrap(go, function(result) {
        return _.head(patchUpModels(extendModels(result.models)));
      }));
    });
    deleteModel = method(function(key, go) {
      return del("/3/Models.json/" + (enc(key)), go);
    });
    getModelBuilders = method(function(go) {
      return get("/3/ModelBuilders.json", go);
    });
    getModelBuilder = method(function(algo, go) {
      return get("/3/ModelBuilders.json/" + algo, go);
    });
    requestModelInputValidation = method(function(algo, parameters, go) {
      return post("/3/ModelBuilders.json/" + algo + "/parameters", encodeObject(parameters), go);
    });
    resolveParameters = method(function(parameters, go) {
      var key, obj, resolved, unresolveds;
      unresolveds = [];
      resolved = {};
      for (key in parameters) {
        obj = parameters[key];
        if (fj.isFuture(obj)) {
          unresolveds.push({
            key: key,
            future: obj
          });
        } else {
          resolved[key] = obj;
        }
      }
      if (unresolveds.length) {
        return (fj.map(unresolveds, (function(a) {
          return a.future;
        })))(function(error, values) {
          var i, j, len, value;
          if (error) {
            return go(error);
          } else {
            for (i = j = 0, len = values.length; j < len; i = ++j) {
              value = values[i];
              resolved[unresolveds[i].key] = value;
            }
            return go(null, resolved);
          }
        });
      } else {
        return go(null, resolved);
      }
    });
    buildModel = method(function(algo, parameters, go) {
      return post("/3/ModelBuilders.json/" + algo, encodeObject(parameters), go);
    });
    createModel = method(function(algo, parameters, go) {
      var build, job, model, resolvedParameters;
      resolvedParameters = resolveParameters(parameters);
      build = fj.lift(resolvedParameters, function(parameters) {
        var trainingFrameKey, validationFrameKey;
        trainingFrameKey = extractFrameKey(parameters.training_frame);
        validationFrameKey = extractFrameKey(parameters.validation_frame);
        delete parameters.training_frame;
        delete parameters.validation_frame;
        if (trainingFrameKey) {
          parameters.training_frame = trainingFrameKey;
        }
        if (validationFrameKey) {
          parameters.validation_frame = validationFrameKey;
        }
        return buildModel(algo, parameters);
      });
      job = fj.lift(build, function(build) {
        return waitForJob(build.jobs[0].key.name);
      });
      model = fj.lift(job, function(job) {
        return getModel(job.dest.name);
      });
      return model(go);
    });
    predict = method(function(parameters, go) {
      return resolveParameters(parameters, function(error, parameters) {
        var frameKey, modelKey;
        if (error) {
          return go(error);
        } else {
          modelKey = extractModelKey(parameters.model);
          frameKey = extractFrameKey(parameters.frame);
          delete parameters.model;
          delete parameters.frame;
          return post("/3/Predictions.json/models/" + (enc(modelKey)) + "/frames/" + (enc(frameKey)), parameters, unwrap(go, function(result) {
            return _.head(result.model_metrics);
          }));
        }
      });
    });
    getPrediction = method(function(modelKey, frameKey, go) {
      return get("/3/ModelMetrics.json/models/" + (enc(modelKey)) + "/frames/" + (enc(frameKey)), unwrap(go, function(result) {
        return _.head(result.model_metrics);
      }));
    });
    getPredictions = method(function(modelKey, frameKey, _go) {
      var go;
      go = function(error, result) {
        var prediction, predictions;
        if (error) {
          return _go(error);
        } else {
          predictions = (function() {
            var j, len, ref, results;
            ref = result.model_metrics;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              prediction = ref[j];
              if (modelKey && prediction.model.name !== modelKey) {
                results.push(null);
              } else if (frameKey && prediction.frame.name !== frameKey) {
                results.push(null);
              } else {
                results.push(prediction);
              }
            }
            return results;
          })();
          return _go(null, (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = predictions.length; j < len; j++) {
              prediction = predictions[j];
              if (prediction) {
                results.push(prediction);
              }
            }
            return results;
          })());
        }
      };
      if (modelKey && frameKey) {
        return get("/3/ModelMetrics.json/models/" + (enc(modelKey)) + "/frames/" + (enc(frameKey)), go);
      } else if (modelKey) {
        return get("/3/ModelMetrics.json/models/" + (enc(modelKey)), go);
      } else if (frameKey) {
        return get("/3/ModelMetrics.json/frames/" + (enc(frameKey)), go);
      } else {
        return get("/3/ModelMetrics.json", go);
      }
    });
    uploadFile = method(function(key, path, go) {
      var formData;
      formData = {
        file: fs.createReadStream(path)
      };
      return upload("/3/PostFile.json?destination_key=" + (enc(key)), formData, go);
    });
    requestCloud = method(function(go) {
      return get('/1/Cloud.json', go);
    });
    requestTimeline = method(function(go) {
      return get('/2/Timeline.json', go);
    });
    requestProfile = method(function(depth, go) {
      return get("/2/Profiler.json?depth=" + depth, go);
    });
    requestStackTrace = method(function(go) {
      return get('/2/JStack.json', go);
    });
    requestLogFile = method(function(nodeIndex, fileType, go) {
      return get("/3/Logs.json/nodes/" + nodeIndex + "/files/" + fileType, go);
    });
    requestNetworkTest = method(function(go) {
      return get('/2/NetworkTest.json', go);
    });
    requestAbout = method(function(go) {
      return get('/3/About.json', go);
    });
    getSchemas = method(function(go) {
      return get('/1/Metadata/schemas.json', go);
    });
    getSchema = method(function(name, go) {
      return get("/1/Metadata/schemas.json/" + (enc(name)), go);
    });
    getEndpoints = method(function(go) {
      return get('/1/Metadata/endpoints.json', go);
    });
    getEndpoint = method(function(index, go) {
      return get("/1/Metadata/endpoints.json/" + index, go);
    });
    deleteAll = method(function(go) {
      return del('/1/RemoveAll.json', go);
    });
    shutdown = method(function(go) {
      return post("/2/Shutdown.json", {}, go);
    });
    return {
      importFile: importFile,
      importFiles: importFiles,
      uploadFile: uploadFile,
      parseFiles: parseFiles,
      createFrame: createFrame,
      importFrame: importFrame,
      splitFrame: splitFrame,
      getFrames: getFrames,
      getFrame: getFrame,
      deleteFrame: deleteFrame,
      getColumnSummary: getColumnSummary,
      createModel: createModel,
      getModels: getModels,
      getModel: getModel,
      deleteModel: deleteModel,
      predict: predict,
      getPredictions: getPredictions,
      getPrediction: getPrediction,
      getJobs: getJobs,
      getJob: getJob,
      cancelJob: cancelJob,
      getSchemas: getSchemas,
      getSchema: getSchema,
      getEndpoints: getEndpoints,
      getEndpoint: getEndpoint,
      deleteAll: deleteAll,
      shutdown: shutdown
    };
  };

  module.exports = lib;

}).call(this);
